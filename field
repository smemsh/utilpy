#!/usr/bin/env python3
"""
field [options] [args]
  select and output fields from each record from stdin

args:
  - 1-arg: field <rangelist>
  - 2-arg: field <indelim> <rangelist>
  - 3-arg: field <indelim> <outdelim> <rangelist>
  - if supplied, indelim is a fixed string, unless -r/--regex
  - indelim defaults to any char in $IFS, or the regex [\\x20\\t\\n]
  - records are split on newlines only so far

rangelist:
  - specifier is a comma separated list of ranges
  - ranges are either single numbers or first-last sequences
  - unspecified Y in X-Y will default to highest Y in the input
  - if first field in range greater than than last, print reversed
  - if any specified fields do not exist in the record, skip them
  - field '0' is the same as all fields (range '1-')

range:
      N: just field number N (1 is first)
     -N: just field Nth from the end (-1 is last)
    N-M: fields N through M (M > N)
    N-M: fields M through N, backwards (N > M)
     N-: fields N through the end
    -N-: fields from Nth from the end, through the end
   N--M: fields N through Mth from end
  -N--M: fields Nth from the end through Mth from the end

examples:
  "echo one two three four five | field 2 -> "two"
  "echo one two three four five | field -2" -> "four"
  "echo one two three four five | field 2-4" -> "two three four"
  "echo one two three four five | field 4-2" -> "four three two"
  "echo one two three four five | field 3-" -> "three four five"
  "echo one two three four five | field -2-" -> "four five"
  "echo one two three | field 1,0" -> "one one two three"
  "echo {1..12} | field -8--10" -> "5 4 3"
  "echo {1..12} | field -8--15" -> "5 4 3 2 1"
  "echo {1..12} | field 3--15" -> "3 2 1"
  "echo {1..12} | field 1-3,-1--2,8,8,10-,-2" -> "1 2 3 12 11 8 8 10 11 12 11"

"""
"""
todo:
  - read from files given as additional arguments
  - /R/: fields matching regex R;
  - /R/-/S/: starting with /R/ and ending with /S/
  - specify record delimiter
  - specify record selection criteria (pattern)
  - field reformatting, eg wrapping, fit in column or on page
  - args like -r record-regex -f range1,range2 -F format1,format2
  - args like -g columnate_group
  - different behaviors for range overlaps (set union, addition)
  - way to disinclude fields ("all fields except...")
  - multiple delimiters, maybe a -i and -d possible for every -f
  - multiple delimiters, as in multiple patterns will serve as one
  - specify od but not id (maybe support -i and -d or -d and -D)
  - implement a "record" in terms of "field?"
  - generalize to make work on byte streams using binary mode
"""

__url__     = 'https://github.com/src/utilpy/'
__author__  = 'Scott Mcdermott <scott@smemsh.net>'
__license__ = 'GPL-2.0'

from sys import exit, hexversion
if hexversion < 0x030900f0: exit("minpython: %x" % hexversion)

import argparse
import re

from traceback import print_exc
from select import select
from types import SimpleNamespace
from sys import argv, stdin, stdout, stderr
from os import (
    getenv, isatty, dup,
    close as osclose,
    EX_OK as EXIT_SUCCESS,
    EX_SOFTWARE as EXIT_FAILURE,
)
from os.path import basename

###

def err(*args, **kwargs):
    print(f"{invname}:", *args, file=stderr, **kwargs)

def bomb(*args, **kwargs):
    err(*args, **kwargs)
    exit(EXIT_FAILURE)

###

def process_args():

    global ifs, ofs
    global args

    def usagex(*args, **kwargs):
        nonlocal p
        p.print_help(file=stderr)
        print(file=stderr)
        bomb(*args, **kwargs)

    # not clear why the interface gives a prefix arg and defaults it, but
    # doesn't allow it to be passed in from anywhere, so we have to override
    #
    class RawTextHelpFormatterEmptyUsageLine(argparse.RawTextHelpFormatter):
        def add_usage(self, usage, actions, groups, prefix=None):
            if prefix is None:
                prefix = ''
            return super(RawTextHelpFormatterEmptyUsageLine, self) \
                .add_usage(usage, actions, groups, prefix)

    p = argparse.ArgumentParser(
        prog            = invname,
        description     = __doc__.strip(),
        allow_abbrev    = False,
        formatter_class = RawTextHelpFormatterEmptyUsageLine,
        usage           = "",
    )

    # whether field separators are fixed patterns or regexes
    fixed = False

    def addopt(p, flagchar, longopt, help=None, /, **kwargs):
        options = list(("-%s --%s" % (flagchar, longopt)).split())
        p.add_argument(*options, help=help, **kwargs)

    def addflag(*args, **kwargs):
        addopt(*args, action='store_true', **kwargs)

    addflag (p, 'r', 'regex', "ifs/ofs are regular expressions")

    args, left = p.parse_known_args(args)

    n = len(left)
    if n == 1: fields = left[0]
    else:
        if not args.regex: fixed = True
        if n == 2: ifs = left[0]; fields = left[1]
        elif n == 3: ifs = left[0]; ofs = left[1]; fields = left[2]
        else: usagex("bad args")

    if fixed: ifs = re.escape(ifs)

    return fields


class FieldRange:
    def __init__(self, start, end):
        self.start = int(start) # start is always supplied
        self.end = None if end is None else int(end)

def parse_fields(rangelist):
    ranges = []
    for fieldrange in rangelist.split(','):
        match = re.fullmatch(r"""
                (?P<start>-?\d+)
                (?P<isrange>-
                    (?P<end>-?\d+)?
                )?
            """, fieldrange, re.VERBOSE)
        if match:
            ns = SimpleNamespace(**match.groupdict())
            if not ns.isrange:
                ns.end = ns.start
            else:
                for endpoint in [ns.start, ns.end]:
                    if endpoint is not None and int(endpoint) == 0:
                        bomb("range spec '0' (all fields) excludes start/end")
            del ns.isrange
            ranges += [FieldRange(**vars(ns))]
            continue
        else:
            bomb(f"bad field range: {fieldrange}")

    return ranges


def field(rangelist):
    ranges = parse_fields(rangelist)
    records = re.split(irs, infile.read(), flags=re.MULTILINE|re.DOTALL)
    for n in [0, -1]:
        if not records[n]: records.pop(n)
    for record in records:
        fields = re.split(ifs, record)
        # https://stackoverflow.com/questions/2197451
        fields = [f for f in fields if f]
        n = len(fields)
        indices = []
        for r in ranges:
            start = r.start or 1
            end = r.end or n
            if start < 0: start = n - abs(start) + 1
            if end < 0: end = n - abs(end) + 1
            step = 1 if start <= end else -1
            offsets = range(start - 1, end - 1 + step, step)
            indices += [i for i in offsets if 0 <= i < n]
        print(ofs.join([fields[i] for i in indices]), end=ors)

###

def main():

    if debug == 1:
        breakpoint()

    rangelist = process_args()

    try: subprogram = globals()[invname]
    except (KeyError, TypeError):
        bomb(f"unimplemented command '{invname}'")

    return subprogram(rangelist)

###

if __name__ == "__main__":

    args = argv[1:]
    invname = basename(argv[0])

    # move stdin, pdb needs stdio fds itself
    stdinfd = stdin.fileno()
    if not isatty(stdinfd) and select([stdin], [], [])[0]:
        infile = open(dup(stdinfd))
        osclose(stdinfd)
        try: stdin = open('/dev/tty')
        except: pass # no ctty, but then pdb would not be in use
    else:
        args = None

    from bdb import BdbQuit
    debug = int(getenv('DEBUG') or 0)
    if debug:
        from pprint import pp
        err('debug: enabled')

    ifs = '[' + getenv('IFS', r'\x20\t\n') + ']'; ofs = "\x20"
    irs = "\n"; ors = "\n"

    try: main()
    except SystemExit: raise
    except BdbQuit: bomb("debug: stop")
    except: print_exc(file=stderr)
    finally: # cpython bug 55589
        try: stdout.flush()
        finally:
            try: stdout.close()
            finally:
                try: stderr.flush()
                finally: stderr.close()
