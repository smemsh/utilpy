#!/usr/bin/env python3
"""
gkeepbak
  read old gkeepapi json state on stdin, do a sync, write to stdout

desc:
  - maintains backups of google keep data
  - reads previously serialized state from itself on stdin
  - if nothing on stdin, obtains keep data anew from api (expensive)
  - otherwise, uses api to sync from upstream, does incremental download
  - write new serialized json to stdout (use next time as input)
  - if no changed records, writes nothing to stdout (reader gets EOF)

usage:
  trap 'echo "gkeepapi cron failure"' err
  umask 077
  set -e
  cd ~/var/gkeepapi
  state=($(compgen -G state-'20????????????.json')) || true
  newname=state-`date +%Y%m%d%H%M%S`.json
  cat ${state:-/dev/null} \
  | GKEEPBAK_EMAIL=scott@smemsh.net \
    GKEEPBAK_TOKEN="$(<~/secrets/gkeepapi)" \
    gkeepbak \
  > .$newname
  test -s .$newname && mv $newname $newname || rm .$newname

deps:
  - https://github.com/kiwiz/gkeepapi/

"""
__url__     = 'https://github.com/smemsh/utilpy/'
__author__  = 'Scott Mcdermott <scott@smemsh.net>'
__license__ = 'GPL-2.0'
__devskel__ = '0.8.1'

from sys import exit, hexversion
if hexversion < 0x030900f0: exit("minpython: %s" % hexversion)

from sys import argv, stdin, stdout, stderr
from select import select

from json import dump, load
from json.decoder import JSONDecodeError

from os import getenv, unsetenv, isatty, dup, devnull
from os import close as osclose
from os import EX_SOFTWARE as EXIT_FAILURE
from os.path import basename

from datetime import datetime as dt

import gkeepapi

###

def err(*args, **kwargs):
    print(*args, file=stderr, **kwargs)

def bomb(*args, **kwargs):
    err(*args, **kwargs)
    exit(EXIT_FAILURE)

###

def gkeepbak():

    (authtok := getenv('GKEEPBAK_TOKEN')) or bomb("authtok unset")
    (email := getenv('GKEEPBAK_EMAIL')) or bomb("email unset")

    keep = gkeepapi.Keep()

    try: olddata = load(infile)
    except JSONDecodeError:
        err("initial run, full download")
        olddata = None

    keep.authenticate(email, authtok, state=olddata)
    newdata = keep.dump()

    fn = lambda f: f['timestamps']['updated']
    oldlast = fn(sorted(olddata['nodes'], key=fn)[-1])
    newlast = fn(sorted(newdata['nodes'], key=fn)[-1])

    if oldlast != newlast:
        old = dt.fromisoformat(oldlast)
        new = dt.fromisoformat(newlast)
        stamp = new.strftime('%Y%m%d%H%M%S')
        since = (new - old).total_seconds() / 60 / 60 / 24
        err(f"newest: {stamp}, since: {since:.1} days")
        dump(newdata, outfile)


def main():

    if debug == 1:
        breakpoint()

    try: subprogram = globals()[invname]
    except (KeyError, TypeError):
        from inspect import trace
        if len(trace()) == 1: bomb("unimplemented")
        else: raise

    return subprogram()

###

if __name__ == "__main__":

    invname = basename(argv[0])

    outfile = stdout
    stdinfd = stdin.fileno()
    stdoutfd = stdout.fileno()

    if isatty(stdinfd):
        # we want either empty or no stdin to trigger json decode error later
        infile = open(devnull)
    else:
        # pdb will need stdio fds, so move and reopen
        try:
            if select([stdin], [], [], 0)[0]:
                infile = open(dup(stdinfd), 'r'); osclose(stdinfd)
                outfile = open(dup(stdoutfd), 'a'); osclose(stdoutfd)
                try:
                    # tty must use fd 0/1 for pdb readline, cpython bug 73582
                    stdin = open('/dev/tty', 'r')
                    stdout = open('/dev/tty', 'a')
                except:
                    pass  # no ctty, but then pdb would not be in use
            else:
                bomb("must supply json or empty data on stdin")

        except KeyboardInterrupt:
            bomb("interrupted")

    from bdb import BdbQuit
    if debug := int(getenv('DEBUG') or 0):
        import pdb
        from pprint import pp
        err('debug: enabled')
        unsetenv('DEBUG')  # otherwise forked children hang

    try: main()
    except BdbQuit: bomb("debug: stop")
    except SystemExit: raise
    except KeyboardInterrupt: bomb("interrupted")
    except:
        from traceback import print_exc
        print_exc(file=stderr)
        if debug: pdb.post_mortem()
        else: bomb("aborting...")
    finally:  # cpython bug 55589
        try:
            outfile.flush()
            stdout.flush()
        finally:
            try:
                outfile.close()
                stdout.close()
            finally:
                try: stderr.flush()
                except: pass
                finally: stderr.close()
